package com.zipline.service.publicItem;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.http.HttpStatus;
import org.springframework.util.StringUtils;

import com.zipline.global.exception.publicItem.EmptyFileException;
import com.zipline.global.exception.publicItem.WrongTextFormateException;
import com.zipline.global.exception.publicItem.FailedDirCreationException;
import com.zipline.global.exception.publicItem.FileReadException;
import com.zipline.global.exception.publicItem.FileSaveException;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;
import java.util.HashSet;
import java.util.Set;

@Service
public class ProxyListUploadService {

    @Value("${proxy.upload.dir:/app/config}")
    private String uploadDir;
    @Value("${proxy.upload.max-file-size:1048576}") // Default 1MB
    private long maxFileSize;
    @Value("${proxy.upload.max-lines:2000}") // Default 2000 lines
    private int maxLines;
    @Value("${proxy.upload.file-name:proxy-list.txt}")
    private String proxyList;

public String saveFile(MultipartFile file){
    boolean isNewFile = false;

    if (file.isEmpty()) {
        throw new EmptyFileException("파일이 비어 있습니다", HttpStatus.BAD_REQUEST);
    }
    if (file.getSize() > maxFileSize) {
        throw new FileSaveException("파일 크기가 제한을 초과했습니다. 최대 허용 크기: " + (maxFileSize / 1024) + "KB", HttpStatus.BAD_REQUEST);
    }
    String fileName = StringUtils.cleanPath(file.getOriginalFilename());
    if (fileName.contains("..")) {
        throw new FileSaveException("파일 이름에 잘못된 경로가 포함되어 있습니다", HttpStatus.BAD_REQUEST);
    }
    String contentType = file.getContentType();
    if (contentType != null && !contentType.equals("text/plain")) {
        throw new FileSaveException("텍스트 파일만 업로드 가능합니다", HttpStatus.BAD_REQUEST);
    } 
   
    // 파일 내용 유효성 검사
    Set<String> uniqueProxies = new HashSet<>();
    try (BufferedReader reader = new BufferedReader(new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {
        String line;
        int lineNumber = 0;
        while ((line = reader.readLine()) != null) {
            lineNumber++;
            
            // 길이 검증 
            if (lineNumber > maxLines) {
                throw new WrongTextFormateException("프록시 목록이 너무 깁니다. 최대 " + maxLines + "줄까지 허용됩니다.", HttpStatus.BAD_REQUEST);
            }

            // 공백을 제거하기 위해 라인 트림
            String trimmedLine = line.trim();
            // 빈 라인 건너뛰기
            if (trimmedLine.isEmpty()) {
                continue;
            }

            // 보이지 않는 문자 제거 및 공백 정규화
            trimmedLine = trimmedLine.replaceAll("\\s+", "").replaceAll("[\\p{Cc}\\p{Cf}\\p{Co}\\p{Cn}]", "");
            // 정리 후 빈 라인이면 건너뛰기
            if (trimmedLine.isEmpty()) {
                continue;
            }

            // IP:PORT 형식 검증 - 더 엄격한 패턴
            if (!trimmedLine.matches("^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?):\\d{1,5}$")) {
                throw new WrongTextFormateException("잘못된 파일 형식입니다. " + lineNumber + "번째 줄이 IP:PORT 형식이어야 합니다: '" + line + "'", HttpStatus.BAD_REQUEST);
            }

            // 포트 번호 범위 검증 (1-65535)
            String[] parts = trimmedLine.split(":");
            int port = Integer.parseInt(parts[1]);
            if (port < 1 || port > 65535) {
                throw new WrongTextFormateException("잘못된 포트 번호입니다. " + lineNumber + "번째 줄: " + port, HttpStatus.BAD_REQUEST);
            }

            // 중복 프록시 검사
            if (!uniqueProxies.add(trimmedLine)) {
                throw new WrongTextFormateException("중복된 프록시가 발견되었습니다: " + trimmedLine, HttpStatus.BAD_REQUEST);
            }
        }
    } catch (IOException e) {
        throw new FileReadException("파일 읽기 중 오류가 발생했습니다", HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // 디렉토리 존재 여부 확인 및 생성
    Path directory = Paths.get(uploadDir);
    try {
        Files.createDirectories(directory);
    } catch (IOException e) {
        throw new FailedDirCreationException("파일 업로드를 위한 디렉토리 생성에 실패했습니다", HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // 안전한 파일 경로 생성
    Path filePath = directory.resolve(proxyList);
    
    // 파일 저장 with atomic write
    try {
        // 임시 파일에 먼저 쓰기
        Path tempFile = Files.createTempFile(directory, "proxy-list", ".tmp");
        Files.write(tempFile, uniqueProxies);

        // 파일이 이미 존재하는지 확인
        isNewFile = !Files.exists(filePath);

        // 아토믹하게 임시 파일을 실제 파일로 이동
        Files.move(tempFile, filePath, java.nio.file.StandardCopyOption.REPLACE_EXISTING, 
                                     java.nio.file.StandardCopyOption.ATOMIC_MOVE);
    } catch (IOException e) {
        throw new FileSaveException("파일 저장 중 오류가 발생했습니다", HttpStatus.INTERNAL_SERVER_ERROR);
    }
    return isNewFile ? "proxy-list.txt 파일이 성공적으로 생성되었습니다" : "proxy-list.txt 파일이 성공적으로 업데이트 되었습니다";
}
}
